[함수 정의] calculate_iou(박스1, 박스2):
    두 박스의 좌표를 (중심,너비,높이)에서 (좌상단, 우하단)으로 변환
    겹치는 영역의 (좌상단, 우하단) 좌표를 계산 (max, min 활용)
    겹치는 영역의 넓이를 계산 (음수면 0으로 처리)
    두 박스의 넓이를 각각 계산
    합집합 영역의 넓이를 계산(박스1 넓이 + 박스2 넓이 - 겹치는 영역 넓이)
    IOU를 계산 (겹치는 영역 넓이 / 합집합 영역 넓이)
    IOU 값 반환

[메인 로직]
1. 설정값들 정의 (이미지 크기, 개수, 숫자 크기, IOU 한계치, 저장 경로 등)
2. 결과 저장할 폴더들 생성
3. MNIST 데이터 불러오기

4. 만들 이미지 개수만큼 [바깥 루프] 시작:
    1. 깨끗한 흰 배경 이미지 생성
    2. 이번 이미지의 라벨(label_list)들을 저장할 빈 리스트 생성
    3. 이번 이미지에 성공적으로 배치된 박스(placed_boxes)들을 저장할 빈 리스트 생성
    4. 이번 이미지에 배치할 숫자(2~3개)(num_digits_to_place)를 무작위로 결정

    5. 성공적으로 배치된 박스 개수가 목표 개수보다 적은 동안 [중간 루프] 반복:
        - (안전장치) 시도(attempt) 횟수 100번(max_attempts)으로 제한, 배치 성공 여부 변수(placed) False로 초기화
        - 시도 횟수가 100번보다 적은 동안 [안쪽 루프] 반복:
            1. 랜덤 크기, 랜덤 위치로 '후보 박스' 하나 생성
	- "겹친다" 변수(is_overlapping) False로 초기화 
            2. '후보 박스'와 '이미 배치된 박스들'을 하나씩 비교하며 충돌 검사:
                - iou = calculate_iou(후보박스, 이미 배치된 박스)
                - 만약 iou > 한계치 이면:
                    - "겹친다"고 표시하고 검사 중단
            3. 만약 "겹치지 않는다"(not is_overlapping)고 판단되면:
                - 배경 이미지에 후보 숫자를 붙여넣기
                - 라벨 리스트(label_list)에 후보 박스의 라벨 정보(label_string) 추가
                - '이미 배치된 박스들' 리스트에 후보 박스 정보 추가
                - 배치 성공 여부(placed)를 True로 변경
                - [안쪽 루프] 빠져나가기 (break)
            4. 겹쳤다면 시도 횟수 1 증가
        
        - 만약 배치에 최종 실패했다면(placed가 False이면):
            - 이번 이미지 생성을 포기하고 [중간 루프] 빠져나가기 (break)
    
    6. 만약 목표한 개수만큼 배치가 다 성공했다면:
        - 최종 이미지를 파일(image_filename)로 저장
        - 라벨 리스트(label_list)에 있는 모든 라벨을 텍스트 파일(label_filename) 하나에 저장

5. 모든 작업 완료 메시지 출력